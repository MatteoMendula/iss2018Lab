/* 
 * ==============================================================
 * applR0.qa
 * R0: the robot moves forward .
 * If the robot detects an obstacle, it stops and emits 
 * 		tasktodo : tasktodo( obstacleAvoidance, "" )
 * Afterward it wits for an event
 * 		taskdone : taskdone( obstacleAvoidance, _ )
  * ==============================================================
 */     
System applR0     
Event usercmd      : usercmd(CMD)     
Event alarmev      : alarm( X )   
Event sonarSensor  : sonar( NAME, DISTANCE )	//From rover or real robot
Event taskexec     : taskexec(  tasktodo( NAME, ARGS ) )			
Event tasktodo     : tasktodo( TASK, ARGS )	    //to other agents
Event taskdone     : taskdone( TASK, ARGS )	    //From other agents

Dispatch alarmmsg  : alarm( X ) 	//same payload as alarmev
 
//pubSubServer  "tcp://192.168.43.229:1883"    
pubSubServer  "tcp://localhost:1883"    		//for testing

Context ctxApplR0 ip [ host="localhost"   port=8019 ]  -g green   //192.168.43.229
EventHandler evh for alarmev -print {	 
	forwardEvent applr0agent -m alarmmsg   
};    
EventHandler evhtask for taskexec -print {	 
	memoCurrentEvent -lastonly for applr0agent    ;
	demo newtaskexecutor for applr0agent
};   
  
QActor applr0agent context ctxApplR0 -pubsub{    
Rules{
	newtaskexecutor :-   
		retract( msg( taskexec, 'event', EMITTER, none, taskexec(  tasktodo( NAME, ARGS ) ), MSGNUM ) ),
		replaceRule( task(tasktodo( NAME, OLDARG ) ) , task(tasktodo( NAME, ARGS ) ) ), //just one
		actorPrintln( task(tasktodo( NAME, ARGS ) ) )
		.	
} 
	Plan init normal [  
		println("applr0agent STARTS") 	
	]  
	switchTo doWork  
	
	Plan doWork  [     
 		emit usercmd : usercmd( robotgui(w(low)) )   //forward	
	]  
	transition   stopAfter 6000000        
  		whenMsg  alarmmsg       -> alarmHandlePolicy ,
 		whenEvent  sonarSensor  -> handleSonarEvents 	 
 	finally repeatPlan
	
	Plan alarmHandlePolicy resumeLastPlan[ 
		printCurrentMessage;  
		println("applr0agent ALARM HANDLING POLICY (stop)... ") ;
 		emit usercmd : usercmd( robotgui(h(low)) ) ;     
		println("applr0agent ALARM HANDLING POLICY DONE ") 
	]  

	Plan handleSonarEvents resumeLastPlan [ 
		printCurrentEvent; 
		onEvent sonarSensor : sonar(realsonar, DISTANCE) -> {
			emit usercmd : usercmd( robotgui(d(low)) ) ;	//right
			delay 750;
			emit usercmd : usercmd( robotgui(h(low)) ) ;	//stop			
			[ !? task(tasktodo( obstacleAvoidance, on ) ) ] {
				emit tasktodo : tasktodo( obstacleAvoidance, "do" );
				addRule waitAnswer
			}else endPlan "" 
		};   
		onEvent sonarSensor : sonar(roversonar, DISTANCE) -> {
			emit usercmd : usercmd( robotgui(d(low)) ) ;	//right
			delay 750;
 			emit usercmd : usercmd( robotgui(h(low)) ) ;	//stop
			[ !? task(tasktodo( obstacleAvoidance, on)) ] {
				println("emitting  tasktodo ") ;
				emit tasktodo : tasktodo( obstacleAvoidance, "do" ) ;
				addRule waitAnswer
			} else endPlan "" 		
		}
  		//other events are ignored
  	 ]  	 
  	 switchTo [ ??waitAnswer ] waitAnswer   
  	 
  	 /*
  	  * If applr1agent is not running we do not have any answer
  	  * The independence of this component is reduced 
  	  */  	  
  	 Plan waitAnswer[
  	 	println("applr0agent WAITS that a passage is found") 
  	 ]
  	 transition stopAfter 60000
		whenEvent taskdone : taskdone(obstacleAvoidance,"ok" ) -> 	doWork
	
//  	 Plan checkTheAnswer [
//  	 	onEvent taskdone : taskdone(obstacleAvoidance,ARG ) -> addRule goon 
//     ]	
//   	 switchTo [ ??goon  ] doWork
//  	 finally repeatPlan  //in case of some other answer
  	 
}//applr0agent