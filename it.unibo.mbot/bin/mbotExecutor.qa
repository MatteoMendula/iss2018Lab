/* 
 * ==============================================================
 * mbotExecutor.qa
 * A robot called rover is able to execute move commands in a 
 * (real + virtual) environment 
 * ==============================================================
 */    
System mbotExecutor            
Event usercmd     : usercmd(CMD)  					//from web gui
Event sonar  	  : sonar(SONAR, TARGET, DISTANCE)	//From (virtual) sonar
Event sonarDetect : sonarDetect(X)					//From (virtual robot) sonar
Event realSonar   : sonar( DISTANCE )				//From real sonar on real robot
Event    polar    : p( Distance, Angle )
Event local_rover : roverState(STATE)				// STATE: ready | ..
 
Dispatch moveRover : cmd( CMD )   					//from usercmdmanager

Context ctxMbotExecutor ip [ host="192.168.43.67"   port=8029 ]  -httpserver   //192.168.43.67
 
/* 
 * -----------------------------------------------------
 * The usercmdmanager handles commands sent by the user
 * -----------------------------------------------------
 */
QActor usercmdmanager context ctxMbotExecutor { 
	Plan init normal[ ]
  	transition stopAfter 3600000   	//1h 
 		whenEvent usercmd   -> execMove  
    	finally repeatPlan   
  	
  	Plan execMove resumeLastPlan[     
     	onEvent usercmd :  usercmd( robotgui(w(X)) ) -> forward rover -m moveRover : cmd(moveForward);    
    	onEvent usercmd :  usercmd( robotgui(s(X)) ) -> forward rover -m moveRover : cmd(moveBackward);  
  		onEvent usercmd :  usercmd( robotgui(a(X)) ) -> forward rover -m moveRover : cmd(turnLeft);   
   		onEvent usercmd :  usercmd( robotgui(d(X)) ) -> forward rover -m moveRover : cmd(turnRight);   
   		onEvent usercmd :  usercmd( robotgui(h(X)) ) -> forward rover -m moveRover : cmd(moveStop);  
    	onEvent usercmd :  usercmd( robotgui(f(X)) ) -> forward rover -m moveRover : cmd(followLine);        
    	onEvent usercmd :  usercmd( robotgui(x(X)) ) -> switchTo terminataAppl ;
    	onEvent usercmd :  usercmd( robotgui(unityAddr(X)) )  -> forward rover -m moveRover : cmd(connectToUnity)  
    ] 
	Plan terminataAppl [    
		stop 40 time ( 10 );
		javaRun it.unibo.rover.mbotConnArduino.mbotStop();
		actorOp terminateSystem
	]
}

/*
 * -----------------------------------------------------
 * The rover is a an interpreter of commands
 * -----------------------------------------------------
 */  
QActor rover context ctxMbotExecutor {   
	Rules{	  
		onRaspberry.
		//unityConfig("localhost", "unityStart.bat").  
		unityConfig("192.168.43.229", "").  
		foundObstacle :- retract( realDistance(D) ), eval( lt, D, 20 ).
	}
	Plan init normal [       
 	    [ !? onRaspberry] javaRun it.unibo.rover.mbotConnArduino.initRasp()	;
	    println("rover START")    
  	] 
    switchTo waitForCmd        
		
   	Plan waitForCmd[  ]  
  	transition stopAfter 3600000   	//1h 
 		whenMsg moveRover   -> execMove 
   	finally repeatPlan    
	
  	Plan execMove resumeLastPlan[     
  		printCurrentMessage;
    	onMsg moveRover : cmd( moveForward )    -> javaRun it.unibo.utils.robotMixMoves.moveRobotAndAvatar("forward",  "40", "60000");     
    	onMsg moveRover : cmd( moveBackward)    -> javaRun it.unibo.utils.robotMixMoves.moveRobotAndAvatar("backward", "40", "60000");  
  		onMsg moveRover : cmd( turnLeft )       -> switchTo turnLeft;   
   		onMsg moveRover : cmd( turnRight )      -> switchTo turnRight ;   
   		onMsg moveRover : cmd( moveStop )       -> javaRun it.unibo.utils.robotMixMoves.moveRobotAndAvatar("stop", "40", "10")  ; 
   		onMsg moveRover : cmd( connectToUnity ) -> switchTo [ not !? unityOn ] connectToUnity ; 
   		onMsg moveRover : cmd( followLine )     -> javaRun it.unibo.rover.mbotConnArduino.mbotLinefollow()     
   	]     
       
   	Plan connectToUnity[ 
  		 [ !? unityConfig(UNITYADDR, BATCH) ] javaRun it.unibo.utils.external.connectRoverToUnity( UNITYADDR, BATCH ) ;
  		 addRule unityOn 
	]   
 	switchTo setAvatarInitialPosition   
 	Plan setAvatarInitialPosition[
    	 backwards 70 time ( 1000 ) ;    	   
   	     right 70 time ( 1000 )   	;
   	     emit local_rover : roverState( ready )	
 	]	
 	switchTo waitForCmd
	
	Plan turnLeft  [
		javaRun it.unibo.rover.mbotConnArduino.mbotLeft();
		[ !? unityOn ] left 40 time(750) else delay 900;
 		javaRun it.unibo.rover.mbotConnArduino.mbotStop()	
	]
	switchTo waitForCmd
	
	Plan turnRight  [
		javaRun it.unibo.rover.mbotConnArduino.mbotRight();
		[ !? unityOn ] right 40 time(750) else  delay 900;
 		javaRun it.unibo.rover.mbotConnArduino.mbotStop()
	]
	switchTo waitForCmd
}  

/*
 * -----------------------------------------------------
 * Convert sonar events into polar
 * -----------------------------------------------------
 */
QActor sonardetector context ctxMbotExecutor{
	Plan init normal [
		println("sonardetector STARTS ")
	]
	switchTo waitForEvents
	
	Plan waitForEvents[ ]    
  	transition stopAfter 3600000   	//1h     
 		whenEvent sonar       ->  sendToRadar,
  		whenEvent sonarDetect ->  showObstcle,
 		whenEvent realSonar   ->  handleRealSonar
  	finally repeatPlan  
	  
	Plan sendToRadar resumeLastPlan [      
  		printCurrentEvent; 		
		onEvent sonar  : sonar(sonar1, TARGET, DISTANCE ) -> emit polar : p(DISTANCE,30) ;
		onEvent sonar  : sonar(sonar2, TARGET, DISTANCE ) -> emit polar : p(DISTANCE,120) 
 	] 
 	
 	Plan handleRealSonar resumeLastPlan[ 
 		printCurrentEvent; 		
		onEvent realSonar   : sonar( DISTANCE ) -> emit polar : p(DISTANCE, 0) 
 	]
	Plan showObstcle resumeLastPlan[
		println( "found obstacle" );		
		emit polar : p(30,90) 
	]
}

/* 
 * -----------------------------------------------------
 * The frontendactivator activates a node front-endserver
 * 
 * WARNING: it is better to activate the server outside this executor,
 * in order to be able to stop it when required
 * -----------------------------------------------------
 */ 
//QActor frontendactivator  context ctxMbotExecutor{
//	Plan init normal [  
// 		nodeOp "./nodeServer/bin/www -o"   //WARNING: takes controls		
//	]
//}