/* 
 * =======================================================================================
 * roverExecutor.qa
 * A robot called rover is able to execute move commands in a VIRTUAL environment 
 * Moreover it emits polar    : p( Distance, Angle ) events
 * =======================================================================================
 */    
System roverExecutor                
Event usercmd      : usercmd(CMD)  					//from web gui
Event alarm        : alarm( X )   				    //from web gui
Event alarmev      : alarm( X )   				    //same payload as alarm
Event sonar  	   : sonar(SONAR, TARGET, DISTANCE)	//From (virtual) sonar
Event sonarSensor  : sonar(NAME, DISTANCE)			////NAME= sonar1 | sonar2 | roversonar	
Event sonarDetect  : sonarDetect(X)					//From (virtual robot) sonar
Event    polar     : p( Distance, Angle )
Event mindcmd      : usercmd(CMD)					//to command a real robot

Dispatch moveRover : usercmd(CMD)    

pubSubServer  "tcp://192.168.43.229:1883"      

Context ctxRoverExecutor ip [ host="localhost"   port=8032 ] -g white -httpserver  
EventHandler evh for usercmd -print {	//event-driven but no Mqtt support yet
 	forwardEvent rover -m moveRover  	//from event to message
};   

QActor mindtobody context ctxRoverExecutor  -pubsub {
	Plan init normal [  println("mindtobody STARTS ")   ] 
	switchTo doWork
	
	Plan doWork[ println("mindtobody WAITS ... ") ]  
	transition stopAfter 3600000   	//1h   
  		whenEvent usercmd -> emitMindEvent
  	finally repeatPlan
  	
  	Plan emitMindEvent resumeLastPlan[
  		printCurrentEvent;
  		onEvent usercmd : usercmd(CMD) -> emit mindcmd : usercmd(CMD)
  	]
}

/*  
 * -----------------------------------------------------
 * The rover is a an interpreter of moveRover dispatch
 * -----------------------------------------------------
 */  
QActor rover context ctxRoverExecutor  -pubsub {         
	Rules{	//unityOn. //set by connectToUnity     
			unityConfig( "unityStart.bat").   
	}
	Plan init normal [  println("rover START")   ] 
    switchTo waitForCmd            
		 
   	Plan waitForCmd[  ]  
  	transition stopAfter 3600000   	//1h   
  		whenEvent alarm : alarm(X) do {
  			//emit via Mqtt a new event (to avoid recursion);
  			emit alarmev : alarm(X) 
  		},
 		whenMsg moveRover   -> execMove  	 
 	finally repeatPlan 
 	  
  	Plan execMove resumeLastPlan[  
  		printCurrentMessage;    
//  		onEvent  mindcmd : usercmd( CMD )              -> forward rover -m moveRover : usercmd( CMD );
    	onMsg moveRover : usercmd( robotgui(h(X)) )    -> stop 40 time(0) ;       
    	onMsg moveRover : usercmd( robotgui(w(X)) )    -> onward 40 time(0) ;  //0 means asynch
    	onMsg moveRover : usercmd( robotgui(s(X)) )    -> backwards 40 time(0) ;
  		onMsg moveRover : usercmd( robotgui(a(X)) )    -> left 40 time(750)  ;   
   		onMsg moveRover : usercmd( robotgui(d(X)) )    -> right 40 time(750) ;   
   		onMsg moveRover : usercmd( robotgui(x(X)) )    -> { //TODO
   			actorOp terminateSystem
   		};  
   		onMsg moveRover :  usercmd( robotgui(unityAddr(X)) ) -> {   
   			[ not !? unityOn ] { 			    	 
	     		 [ !? unityConfig( BATCH) ]  //Unity is on the current host
	     		 		javaRun it.unibo.utils.external.connectRoverToUnity(BATCH);
	  		 	 addRule unityOn ;
	  		 	 //setAvatarInitialPosition
      	 		 backwards 70 time ( 1000 ) ;    	    
   	     	     right     70 time ( 1000 )      		  
    	    } else println("UNITY ALREADY ACTIVATED")	
    	}	    
   	]        
//   	switchTo waitForCmd        
}  

/*
 * -----------------------------------------------------
 * Convert sonar events into polar
 * -----------------------------------------------------
 */
QActor sonardetector context ctxRoverExecutor -pubsub {  
	Plan init normal [	println("sonardetector STARTS ") ]
	switchTo waitForEvents       
	  
	Plan waitForEvents[ ]      
  	transition stopAfter 3600000   	//1h         
  		//these events can be captured because sonardetector is in the  context ctxRoverExecutor
 		whenEvent sonar       ->  sendToRadar,
  		whenEvent sonarDetect ->  showObstcle
  	finally repeatPlan  
	     
	Plan sendToRadar resumeLastPlan [      
 		onEvent sonar  : sonar(NAME,   TARGET, DISTANCE ) -> emit sonarSensor : sonar(NAME, DISTANCE) ;
		onEvent sonar  : sonar(sonar1, TARGET, DISTANCE ) -> emit polar : p(DISTANCE,30)  ;
		onEvent sonar  : sonar(sonar2, TARGET, DISTANCE ) -> emit polar : p(DISTANCE,120) 
 	]  	
	Plan showObstcle resumeLastPlan[
		println( "found obstacle" );	
		onEvent sonarDetect  : sonarDetect( TARGET ) -> emit sonarSensor : sonar(roversonar, 30)  ;
		emit polar : p(30,90) 
	]
}